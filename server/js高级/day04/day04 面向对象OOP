day04 面向对象OOP
  面向过程
    和对象一起看电影
    有一个对象  
    找电影院    
    买票       
    进电影院  
    检票
    看电影
    看完走人 

  面向对象 
    和对象一起看电影
    有一个对象  
    电影院 

1. Object 对象
  在程序中都是用一个对象来描述具体的东西. 
  具体的东西包含 属性 和 功能
     属性: 描述一个东西特点的变量, 一个值.
     功能:描述具体东西可执行的操作，程序中看成是方法． 
  什么是对象：无序的属性和方法的集合，属性可以包含基本数据类型，对象或函数．
  
２．面向对象的三大特点:
  1. 封装: 把属性和方法集中定义在一个对象中.为了代码重用!

  2. 继承: 父对象中的成员子对象可以直接使用,无需创建. 为了代码重用,节约内存. JS中的继承都是通过 原型 来实现的. 

  3. 多态: 同一个方法, 在不同的情况下可以呈现不同的状态, 为了体现子对象和父对象之间的差异.

3. 对象的封装 4种方式
 3.1 对象直接量   var obj = {}; 
     1. 访问对象的属性: 2种
         obj.属性名 / obj['属性名'] 
     2. 访问的属性名不存在, 不会报错, 返回 
        undefined
     3. 给对象添加属性和方法:
         obj.属性名 = 属性值;
         obj.方法名 = function(){...}    
             　   

 3.2 new 关键字  var obj = new Object();
                 obj.属性名 = 值;
                 obj.方法名 = function(){}

 3.3 工厂模式 
      使用函数封装一个对象,反复的调用这个函数
      问题: 没有解决对象识别的问题. 



4. 构造函数 *** 
   4.1 定义构造函数 
      function 构造函数名(参数列表){
         this.属性名 = 参数值1;
         this.方法名 = function(){
             this...
         }
      }
   4.2 使用 new 来调用构造函数 
        - 实例化一个xx类型的对象
       var obj = new 构造函数();          
   
   4.3 构造函数名开头字母要大写 
       Student Array Function Object 

   4.4 只要能new出来的都是构造函数, 11个内置对象除了Math不能new,其他的都可以     
 

对象的继承 - 原型 prototype 
 1. JS 中的一切继承都是通过 原型对象 来实现的.
 2. 我们创建的每一个函数都有一个属性(prototype).
     这个属性是一个指针, 指向这个函数的原型对象.
 3. new 的四件事 ****
    3.1 创建新的空对象
    3.2 将构造函数内部的作用域赋给新对象(将构造函数内部的this指向新对象).
    3.3 将子对象的__proto__属性指向构造函数的原型对象
    3.4 执行构造函数中的代码 

 4. 每一个原型对象都有一个 constructor 属性
    指向它的构造函数. 

 5. 方法定义原型对象上的好处是: 所有实例化出来的子对象都共享它的属性和方法.

原型链(prototype chain):
  1. 任何对象都有__proto__属性继承其父对象,由各级父对象逐级继承,实现的链式结构叫原型链.

  2. Object.prototype是所有对象的顶级父对象. 它的父对象是 null. 

  3. Function.prototype是所有函数的父对象, 它的父对象是 Object.prototype 

  4. 原型链控制着属性和方法的使用顺序, 自己没有就上原型链去找. 找到Object.prototype都没有,返回 undefined.
  
  5. 自己的实例有属性,就用自己的,不用原型对象的,自己没有才去原型链上去找.
          
判断自有属性和共有属性 
  1. var bool = obj.hasOwnProperty('属性名');
     返回 true, 表示是自有属性
     返回false, 表示共有或没有

  2. '属性名' in obj ;可判断共有(检查了整个原型
                                 链)
      返回 true , 一定是共有   
